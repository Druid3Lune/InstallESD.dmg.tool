#!/usr/bin/env ruby
STDOUT.sync = true

$:.unshift File.join(File.dirname(__FILE__), *%w{ .. lib })

require 'optparse'
require 'iesd'

begin
  raise "This tool is only supported on OS X." unless Kernel.system('[ "$(/usr/bin/uname)" = "Darwin" ]')
rescue Exception => e
  opoo e.message
  abort
end

options = {
  :input => nil,
  :output => nil,
  :output_type => :root,
  :install_kexts => [],
  :remove_kexts => [],
  :kernelcache => nil,
  :osinstall => nil,
  :mach_kernel => true,
}

optparse = OptionParser.new do |opts|
  opts.banner = "Usage: #{File.basename $0} -i <inputfile> -o <outputfile> [options]"

  opts.separator ""
  opts.separator "Specific options:"

  opts.on("-i", "--input inputfile",
          "Specify inputfile (dmg or app)") do |input|
    options[:input] = File.absolute_path input
  end

  opts.on("-o", "--output outputfile",
          "Specify outputfile (dmg)") do |output|
    options[:output] = File.absolute_path output
    options[:output] << ".dmg" if File.extname(options[:output]).downcase != ".dmg"
  end

=begin
  opts.on("--input-type type", [:root, :container, :app, :app_container],
          "Specify input type (root, container, app)") do |type|
    options[:input_type] = type
  end

  opts.on("--output-type type", [:root, :container, :app_container],
          "Specify output type (root, container, app)") do |type|
    options[:output_type] = type
  end
=end

  opts.on("--install-kexts x.kext,y.kext,z.kext", Array, "Specify list of kexts to install") do |list|
    options[:install_kexts] = list.map { |kext| File.absolute_path kext }
  end

  opts.on("--remove-kexts x.kext,y.kext,z.kext", Array, "Specify list of kexts to remove") do |list|
    options[:remove_kexts] = list
  end

  opts.on("-c", "--[no-]rebuild-kernelcache", "Rebuild kernelcache") do |c|
    options[:kernelcache] = c
  end

  opts.on("-k", "--[no-]mach-kernel", "Use mach_kernel as fallback") do |k|
    options[:mach_kernel] = k
  end

  opts.on("-p", "--[no-]post-install", "Patch OSInstall.pkg for post install") do |p|
    options[:osinstall] = p
  end

  opts.on("-v", "--[no-]verbose", "Run verbosely") do |v|
    ENV['VERBOSE'] = '1'
  end

  opts.separator ""
  opts.separator "Common options:"

  opts.on_tail("-h", "--help", "Show this message") do
    puts opts
    exit
  end
end

begin
  optparse.parse!
  missing_options = [:input, :output].select { |param| options[param].nil? }
  raise "missing options: #{(missing_options.map { |param| "-#{param.to_s[0]}" }).join(', ')}" unless missing_options.empty?
rescue OptionParser::InvalidOption, OptionParser::MissingArgument
  onoe $!.to_s
  puts optparse
  abort
rescue SystemExit
  raise
rescue Exception => e
  onoe e.message
  puts optparse
  abort
end

begin
  raise "input file does not exist" unless File.exist? options[:input]
  raise "output file already exists" if File.exist? options[:output]
  options[:install_kexts].each { |kext|
    raise "invalid kext: #{kext}" unless File.exist? File.join(kext, *%w{Contents MacOS}, File.basename(kext), ".kext")
  }
  options[:remove_kexts].select { |kext|
    if File.extname(kext) == ".kext"
      true
    else
      opoo "invalid kext: #{kext}"
      false
    end
  }

  if (iesd = IESD.new options[:input])
    iesd.export options
  else
    raise "invalid input file"
  end
rescue Exception => e
  onoe e.message
  abort
end

